@model List<Gymify.Application.DTOs.WorkoutsFeed.WorkoutDayDto>

@{
    ViewData["Title"] = "WorkoutsFeed";
}

<h2>Workouts Feed</h2>

<div id="filters-container" style="margin-bottom:20px;">

    <div style="display:flex; gap:20px; align-items:center;">

        <select id="filter-type" style="padding:6px 10px;">
            <option value="mine">Show my workouts</option>
            <option value="all">Show all workouts</option>
        </select>

        <input type="text" id="author-search"
               placeholder="Search by author"
               style="padding:6px 10px; display:none; width:200px;" />

        <select id="sort-type" style="padding:6px 10px;">
            <option value="desc">The newest first</option>
            <option value="asc">The oldest first</option>
        </select>
    </div>

</div>

<div id="workout-feed-container">
    @await Html.PartialAsync("WorkoutsList", Model) 
</div>

<button id="load-more-btn" data-page="1" style="margin-top:20px;">
    Load more
</button>

@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', function () {

            const feed = document.getElementById('workout-feed-container');
            const loadMoreBtn = document.getElementById('load-more-btn');
            const filterType = document.getElementById('filter-type');
            const authorSearch = document.getElementById('author-search');
            const sortType = document.getElementById('sort-type');

            let debounceTimer;

            /**
             * Повертає колір HSL від червоного (0) до зеленого (120)
             * param {number} xp - Поточний XP
             * param {number} min - Мінімальний XP у діапазоні
             * param {number} max - Максимальний XP у діапазоні
             * returns {string} HSL колір (e.g., 'hsl(120, 75%, 90%)')
             */
            function getXPColor(xp, min, max) {
                // Запобігання ділення на нуль, якщо всі значення однакові
                if (max <= min) {
                    return 'hsl(120, 75%, 90%)'; // Світло-зелений
                }


                const percentage = (xp - min) / (max - min);


                const hue = percentage * 120;

                return `hsl(${hue}, 75%, 90%)`;
            }

            /**
             * Застосовує кольорову "теплову карту" на основі XP до днів і тренувань.
             * Працює лише при вибраному фільтрі "Show my workouts".
             */
            function applyHeatmap() {
                const onlyMy = filterType.value === 'mine';
                const allDayEntries = feed.querySelectorAll('.day-entry');

                // 1. ОЧИЩЕННЯ (Видаляємо класи та інлайн-стилі)
                allDayEntries.forEach(day => {
                    const header = day.querySelector('.day-header');
                    if (header) {
                        // Видаляємо клас і скидаємо колір фону
                        header.classList.remove('heatmap-day-active');
                        header.style.backgroundColor = ''; 
                    }
                    day.querySelectorAll('a[data-workout-xp]').forEach(workout => {
                        // Видаляємо клас і скидаємо колір фону
                        workout.classList.remove('heatmap-workout-active');
                        workout.style.backgroundColor = '';
                        workout.style.cssText = ''; // Залишаємо це для гарантованого скидання
                    });
                });

                if (!onlyMy) {
                    return;
                }

                // 2. ЗБІР ГЛОБАЛЬНОГО ДІАПАЗОНУ (для заголовків днів)
                const daysWithXp = Array.from(allDayEntries).filter(day => day.dataset.dayXp);
                if (daysWithXp.length === 0) return;

                let globalMinXP = Infinity;
                let globalMaxXP = -Infinity;

                daysWithXp.forEach(day => {
                    const xp = parseInt(day.dataset.dayXp, 10);
                    if (!isNaN(xp)) {
                        globalMinXP = Math.min(globalMinXP, xp);
                        globalMaxXP = Math.max(globalMaxXP, xp);
                    }
                });

                if (globalMinXP === Infinity) return;


                // 3. ЗАСТОСУВАННЯ КОЛЬОРІВ ТА КЛАСІВ
                daysWithXp.forEach(day => {
                    const dayXP = parseInt(day.dataset.dayXp, 10);
                    const header = day.querySelector('.day-header');

                    if (!isNaN(dayXP) && header) {
                        // 3a. КОЛІР ДНЯ (на основі ГЛОБАЛЬНОГО діапазону)
                        header.style.backgroundColor = getXPColor(dayXP, globalMinXP, globalMaxXP);
                        header.classList.add('heatmap-day-active'); // Додаємо клас для color: #333
                    }

                    // 3b. КОЛІР ТРЕНУВАНЬ (на основі ЛОКАЛЬНОГО діапазону дня)
                    const workoutsInDay = day.querySelectorAll('a[data-workout-xp]');
                    if (workoutsInDay.length === 0) return;

                    let localMinXP = Infinity;
                    let localMaxXP = -Infinity;

                    // Знаходимо ЛОКАЛЬНИЙ min/max
                    workoutsInDay.forEach(workout => {
                        const workoutXP = parseInt(workout.dataset.workoutXp, 10);
                        if (!isNaN(workoutXP)) {
                            localMinXP = Math.min(localMinXP, workoutXP);
                            localMaxXP = Math.max(localMaxXP, workoutXP);
                        }
                    });

                    if (localMinXP === Infinity) return;

                    workoutsInDay.forEach(workout => {
                        const workoutXP = parseInt(workout.dataset.workoutXp, 10);
                        if (isNaN(workoutXP)) return;

                        const workoutColor = getXPColor(workoutXP, localMinXP, localMaxXP);

                        workout.style.backgroundColor = workoutColor;

                        workout.classList.add('heatmap-workout-active');
                    });
                });
            }

            function getFilterParams() {
                return {
                    onlyMy: filterType.value === 'mine',
                    authorName: authorSearch.value.trim(),
                    byDescending: sortType.value === 'desc'
                };
            }

            async function reloadFeed() {
                const { onlyMy, authorName, byDescending } = getFilterParams();

                let params = new URLSearchParams();
                params.append('page', 0); 
                params.append('onlyMy', onlyMy);
                params.append('byDescending', byDescending);
                params.append('authorName', authorName);

                const url = '@Url.Action("LoadMoreWorkouts")?' + params.toString();

                try {
                    const response = await fetch(url);
                    const html = await response.text();

                    feed.innerHTML = html; 
                    loadMoreBtn.dataset.page = 1; 

                    if (html.trim().length === 0) {
                        feed.innerHTML = '<p style="text-align:center;">Workouts not found.</p>';
                        loadMoreBtn.style.display = 'none';
                    } else {
                        loadMoreBtn.style.display = 'block';
                    }

                    applyHeatmap();
                } 
                catch (e) { /* ... обробка помилок ... */ }
            }

            async function loadMoreWorkouts() {
                const nextPage = parseInt(loadMoreBtn.dataset.page);
                const { onlyMy, authorName, byDescending } = getFilterParams();

                let params = new URLSearchParams();
                params.append('page', nextPage);
                params.append('onlyMy', onlyMy);
                params.append('byDescending', byDescending);
                params.append('authorName', authorName);

                const url = '@Url.Action("LoadMoreWorkouts")?' + params.toString();

                try {
                    const response = await fetch(url);
                    const html = await response.text();

                    if (html.trim().length === 0) {
                        loadMoreBtn.style.display = 'none';
                        return;
                    }

                    let temp = document.createElement('div');
                    temp.innerHTML = html;

                    const newDayEntries = temp.querySelectorAll('.day-entry');

                    newDayEntries.forEach(newDay => {
                        const dayId = newDay.dataset.dayId; 

                        if (!dayId) {
                            feed.appendChild(newDay);
                            return;
                        }

                        const existingDay = feed.querySelector(`.day-entry[data-day-id='${dayId}']`); 

                        if (existingDay) {

                            const newWorkoutList = newDay.querySelector('.workout-list');
                            const existingWorkoutList = existingDay.querySelector('.workout-list');

                            if (newWorkoutList && existingWorkoutList) {

                                const existingDayXP = parseInt(existingDay.dataset.dayXp, 10) || 0;
                                const newDayXP = parseInt(newDay.dataset.dayXp, 10) || 0;
                                const totalXP = existingDayXP + newDayXP;

                                const existingHeaderSpan = existingDay.querySelector('.day-header span:nth-child(2)');

                                const existingMatch = existingHeaderSpan.textContent.match(/Workouts:(\d+)/);
                                const existingWorkoutCount = existingMatch ? parseInt(existingMatch[1], 10) : 0;

                                const newMatch = newDay.querySelector('.day-header span:nth-child(2)').textContent.match(/Workouts:(\d+)/);
                                const newWorkoutCountInBatch = newMatch ? parseInt(newMatch[1], 10) : 0;

                                const totalWorkoutCount = existingWorkoutCount + newWorkoutCountInBatch;

                                while (newWorkoutList.firstChild) {
                                    existingWorkoutList.appendChild(newWorkoutList.firstChild);
                                }

                                if (onlyMy) {
                                    existingDay.dataset.dayXp = totalXP;
                                }

                                if (existingHeaderSpan) {
                                     existingHeaderSpan.innerHTML = `Workouts:${totalWorkoutCount} ${onlyMy ? `| XP:${totalXP}` : ''}`;
                                }
                            }

                            newDay.remove(); 
                        } else {
                            feed.appendChild(newDay);
                        }
                    });


                    loadMoreBtn.dataset.page = nextPage + 1;
                    applyHeatmap(); 

                    while (temp.firstChild) {
                        feed.appendChild(temp.firstChild); 
                    }

                } catch (e) { 
                    console.error("Error loading more workouts:", e);
                }
            }

            // SHOW / HIDE AUTHOR SEARCH & RELOAD
            filterType.addEventListener('change', function () {
                if (filterType.value === 'all') {
                    authorSearch.style.display = 'block';
                } else {
                    authorSearch.style.display = 'none';
                    authorSearch.value = '';
                }
                reloadFeed();
            });

            // SORT CHANGE & RELOAD
            sortType.addEventListener('change', reloadFeed);

            // DEBOUNCE AUTHOR SEARCH & RELOAD
            authorSearch.addEventListener('input', function () {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(reloadFeed, 400);
            });

            // LOAD MORE CLICK
            loadMoreBtn.addEventListener('click', loadMoreWorkouts);

            // COLLAPSING / EXPANDING DAYS
            feed.addEventListener('click', function (event) {
                const header = event.target.closest('.day-header');
                if (header) {
                    const workoutList = header.nextElementSibling;
                    if (!workoutList) return;
                    
                    if (workoutList.style.display === 'block') {
                        slideUp(workoutList, 300);
                    } else {
                        slideDown(workoutList, 300);
                    }
                }
            });

            /**
             * Плавне приховування елемента.
             * param {HTMLElement} element
             * param {number} duration
             */
            function slideUp(element, duration) {
                element.style.height = element.offsetHeight + 'px';
                element.style.transitionProperty = 'height, margin, padding';
                element.style.transitionDuration = duration + 'ms';
                element.style.boxSizing = 'border-box';
                element.offsetHeight; // force repaint
                element.style.overflow = 'hidden';
                element.style.height = 0;
                element.style.paddingTop = 0;
                element.style.paddingBottom = 0;
                element.style.marginTop = 0;
                element.style.marginBottom = 0;
                window.setTimeout(function () {
                    element.style.display = 'none';
                    element.style.removeProperty('height');
                    element.style.removeProperty('padding-top');
                    element.style.removeProperty('padding-bottom');
                    element.style.removeProperty('margin-top');
                    element.style.removeProperty('margin-bottom');
                    element.style.removeProperty('overflow');
                    element.style.removeProperty('transition-duration');
                    element.style.removeProperty('transition-property');
                }, duration);
            }

            /**
             * Плавне відображення елемента.
             * param {HTMLElement} element
             * param {number} duration
             */
            function slideDown(element, duration) {
                element.style.removeProperty('display');
                let display = window.getComputedStyle(element).display;
                if (display === 'none') {
                    display = 'block';
                }
                element.style.display = display;
                let height = element.offsetHeight;
                element.style.height = 0;
                element.style.paddingTop = 0;
                element.style.paddingBottom = 0;
                element.style.marginTop = 0;
                element.style.marginBottom = 0;
                element.style.overflow = 'hidden';
                element.offsetHeight; // force repaint
                element.style.transitionProperty = 'height, margin, padding';
                element.style.transitionDuration = duration + 'ms';
                element.style.height = height + 'px';
                element.style.removeProperty('padding-top');
                element.style.removeProperty('padding-bottom');
                element.style.removeProperty('margin-top');
                element.style.removeProperty('margin-bottom');
                window.setTimeout(function () {
                    element.style.removeProperty('height');
                    element.style.removeProperty('overflow');
                    element.style.removeProperty('transition-duration');
                    element.style.removeProperty('transition-property');
                }, duration);
            }

            applyHeatmap(); 
        });
    </script>
}