@model List<Gymify.Application.DTOs.WorkoutsFeed.WorkoutDayDto>

@{
    ViewData["Title"] = "WorkoutsFeed";
}

<h2>Workouts Feed</h2>

<div id="filters-container" style="margin-bottom:20px;">

    <div style="display:flex; gap:20px; align-items:center;">

        <select id="filter-type" style="padding:6px 10px;">
            <option value="mine">Show my workouts</option>
            <option value="all">Show all workouts</option>
        </select>

        <input type="text" id="author-search"
               placeholder="Search by author"
               style="padding:6px 10px; display:none; width:200px;" />

        <select id="sort-type" style="padding:6px 10px;">
            <option value="desc">The newest first</option>
            <option value="asc">The oldest first</option>
        </select>
    </div>

</div>

<div id="workout-feed-container">
    @await Html.PartialAsync("WorkoutsList", Model) 
</div>

<button id="load-more-btn" data-page="1" style="margin-top:20px;">
    Load more
</button>

@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', function () {

            const feed = document.getElementById('workout-feed-container');
            const loadMoreBtn = document.getElementById('load-more-btn');
            const filterType = document.getElementById('filter-type');
            const authorSearch = document.getElementById('author-search');
            const sortType = document.getElementById('sort-type');

            let debounceTimer;

            /**
             * Повертає колір HSL від червоного (0) до зеленого (120)
             * param {number} xp - Поточний XP
             * param {number} min - Мінімальний XP у діапазоні
             * param {number} max - Максимальний XP у діапазоні
             * returns {string} HSL колір (e.g., 'hsl(120, 75%, 90%)')
             */
            function getXPColor(xp, min, max) {
                // Запобігання ділення на нуль, якщо всі значення однакові
                if (max <= min) {
                    return 'hsl(120, 75%, 90%)'; // Світло-зелений
                }


                const percentage = (xp - min) / (max - min);


                const hue = percentage * 120;

                return `hsl(${hue}, 75%, 90%)`;
            }

            /**
             * Застосовує кольорову "теплову карту" на основі XP до днів і тренувань.
             * Працює лише при вибраному фільтрі "Show my workouts".
             */
            function applyHeatmap() {
                const onlyMy = filterType.value === 'mine';
                const allDayEntries = feed.querySelectorAll('.day-entry');
                
                // 1. ОЧИЩЕННЯ
                if (!onlyMy) {
                    allDayEntries.forEach(day => {
                        const header = day.querySelector('.day-header');
                        if (header) {
                            header.style.backgroundColor = '';
                            header.style.color = '';
                        }
                        day.querySelectorAll('a[data-workout-xp]').forEach(workout => {
                            workout.style.cssText = ''; // Скидання всіх inline стилів
                        });
                    });
                    return;
                }

                // 2. ЗБІР ГЛОБАЛЬНОГО ДІАПАЗОНУ (для заголовків днів)
                const daysWithXp = Array.from(allDayEntries).filter(day => day.dataset.dayXp);
                if (daysWithXp.length === 0) return;

                let globalMinXP = Infinity;
                let globalMaxXP = -Infinity;

                daysWithXp.forEach(day => {
                    const xp = parseInt(day.dataset.dayXp, 10);
                    if (!isNaN(xp)) {
                        globalMinXP = Math.min(globalMinXP, xp);
                        globalMaxXP = Math.max(globalMaxXP, xp);
                    }
                });

                if (globalMinXP === Infinity) return;


                // 3. ЗАСТОСУВАННЯ КОЛЬОРІВ
                daysWithXp.forEach(day => {
                    const dayXP = parseInt(day.dataset.dayXp, 10);
                    const header = day.querySelector('.day-header');
                    
                    if (!isNaN(dayXP) && header) {
                        // 3a. КОЛІР ДНЯ (на основі ГЛОБАЛЬНОГО діапазону)
                        header.style.backgroundColor = getXPColor(dayXP, globalMinXP, globalMaxXP);
                        header.style.color = '#333';
                    }

                    // 3b. КОЛІР ТРЕНУВАНЬ (на основі ЛОКАЛЬНОГО діапазону дня)
                    const workoutsInDay = day.querySelectorAll('a[data-workout-xp]');
                    if (workoutsInDay.length === 0) return;

                    let localMinXP = Infinity;
                    let localMaxXP = -Infinity;

                    // Знаходимо ЛОКАЛЬНИЙ min/max
                    workoutsInDay.forEach(workout => {
                        const workoutXP = parseInt(workout.dataset.workoutXp, 10);
                        if (!isNaN(workoutXP)) {
                            localMinXP = Math.min(localMinXP, workoutXP);
                            localMaxXP = Math.max(localMaxXP, workoutXP);
                        }
                    });

                    if (localMinXP === Infinity) return;

                    workoutsInDay.forEach(workout => {
                        const workoutXP = parseInt(workout.dataset.workoutXp, 10);
                        if (isNaN(workoutXP)) return;

                        const workoutColor = getXPColor(workoutXP, localMinXP, localMaxXP);

                        workout.style.backgroundColor = workoutColor;
                        workout.style.color = '#333'; 
                        workout.style.padding = '2px 5px';
                        workout.style.borderRadius = '4px';
                        workout.style.display = 'inline-block';
                    });
                });
            }

            function getFilterParams() {
                return {
                    onlyMy: filterType.value === 'mine',
                    authorName: authorSearch.value.trim(),
                    byDescending: sortType.value === 'desc',
                    page: 0,
                    anchorDate: loadMoreBtn.dataset.anchorDate || ''
                };
            }

            async function reloadFeed() {
                const { onlyMy, authorName, byDescending } = getFilterParams();
                let anchorDate = null;
                const anchorUrl = '@Url.Action("GetAnchorDate")?' + anchorParams.toString();

                try {
                    const response = await fetch(anchorUrl);
                    const data = await response.json();
                    // Якщо data.anchorDate порожня, це означає, що за поточними фільтрами даних немає.
                    anchorDate = data.anchorDate;

                    if (!anchorDate) {
                        feed.innerHTML = '<p style="text-align:center;">Workouts not found.</p>';
                        loadMoreBtn.style.display = 'none';
                        loadMoreBtn.dataset.anchorDate = '';
                        applyHeatmap(); 
                        return;
                    }
                } catch (e) {
                    console.error("Error fetching anchor date:", e);
                    feed.innerHTML = '<p>Error when loading data.</p>';
                    loadMoreBtn.style.display = 'none';
                    return;
                }

                // 2. ЯКЩО ДАНІ Є, ЗАВАНТАЖУЄМО ПЕРШУ СТОРІНКУ

                let params = new URLSearchParams();
                params.append('page', 0);
                params.append('onlyMy', onlyMy);
                params.append('byDescending', byDescending);
                params.append('authorName', authorName);

                params.append('anchorDate', anchorDate); 

                loadMoreBtn.dataset.anchorDate = anchorDate; 

                const url = '@Url.Action("LoadMoreWorkouts")?' + params.toString();

                try {
                        const response = await fetch(url);
                        const html = await response.text();

                        feed.innerHTML = html;
                        loadMoreBtn.dataset.page = 1;

                        if (html.trim().length === 0) {
                            feed.innerHTML = '<p style="text-align:center;">Workouts not found.</p>';
                            loadMoreBtn.style.display = 'none';
                        } else {
                            loadMoreBtn.style.display = 'block'; 
                        }

                        applyHeatmap();
                    } 
                catch (e) {
                        console.error("Error reloading feed:", e);
                        feed.innerHTML = '<p>Error when loading workouts.</p>';
                        loadMoreBtn.style.display = 'none';
                    }
            }

            /**
             * Завантажує наступну сторінку тренувань.
             */
            async function loadMoreWorkouts() {
                const nextPage = parseInt(loadMoreBtn.dataset.page);
                const { onlyMy, authorName, byDescending, anchorDate } = getFilterParams();
                
                if (!byDescending && !anchorDate) {
                    loadMoreBtn.style.display = 'none';
                    return; 
                }

                let params = new URLSearchParams();
                params.append('page', nextPage);
                params.append('onlyMy', onlyMy);
                params.append('byDescending', byDescending);
                params.append('authorName', authorName);
                
                if (anchorDate) {
                    params.append('anchorDate', anchorDate);
                }

                const url = '@Url.Action("LoadMoreWorkouts")?' + params.toString();

                try {
                    const response = await fetch(url);
                    const html = await response.text();

                    if (html.trim().length === 0) {
                        loadMoreBtn.style.display = 'none';
                        return;
                    }

                    // Додавання нового HTML до контейнера
                    let temp = document.createElement('div');
                    temp.innerHTML = html;
                    while (temp.firstChild) {
                        feed.appendChild(temp.firstChild);
                    }

                    loadMoreBtn.dataset.page = nextPage + 1;
                    applyHeatmap();

                } catch (e) {
                    console.error("Error loading more workouts:", e);
                    // Можливо, залишити кнопку, але сповістити користувача про помилку?
                }
            }

            // SHOW / HIDE AUTHOR SEARCH & RELOAD
            filterType.addEventListener('change', function () {
                if (filterType.value === 'all') {
                    authorSearch.style.display = 'block';
                } else {
                    authorSearch.style.display = 'none';
                    authorSearch.value = '';
                }
                reloadFeed();
            });

            // SORT CHANGE & RELOAD
            sortType.addEventListener('change', reloadFeed);

            // DEBOUNCE AUTHOR SEARCH & RELOAD
            authorSearch.addEventListener('input', function () {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(reloadFeed, 400);
            });

            // LOAD MORE CLICK
            loadMoreBtn.addEventListener('click', loadMoreWorkouts);

            // COLLAPSING / EXPANDING DAYS
            feed.addEventListener('click', function (event) {
                const header = event.target.closest('.day-header');
                if (header) {
                    const workoutList = header.nextElementSibling;
                    if (!workoutList) return;
                    
                    if (workoutList.style.display === 'block') {
                        slideUp(workoutList, 300);
                    } else {
                        slideDown(workoutList, 300);
                    }
                }
            });

            /**
             * Плавне приховування елемента.
             * param {HTMLElement} element
             * param {number} duration
             */
            function slideUp(element, duration) {
                element.style.height = element.offsetHeight + 'px';
                element.style.transitionProperty = 'height, margin, padding';
                element.style.transitionDuration = duration + 'ms';
                element.style.boxSizing = 'border-box';
                element.offsetHeight; // force repaint
                element.style.overflow = 'hidden';
                element.style.height = 0;
                element.style.paddingTop = 0;
                element.style.paddingBottom = 0;
                element.style.marginTop = 0;
                element.style.marginBottom = 0;
                window.setTimeout(function () {
                    element.style.display = 'none';
                    element.style.removeProperty('height');
                    element.style.removeProperty('padding-top');
                    element.style.removeProperty('padding-bottom');
                    element.style.removeProperty('margin-top');
                    element.style.removeProperty('margin-bottom');
                    element.style.removeProperty('overflow');
                    element.style.removeProperty('transition-duration');
                    element.style.removeProperty('transition-property');
                }, duration);
            }

            /**
             * Плавне відображення елемента.
             * param {HTMLElement} element
             * param {number} duration
             */
            function slideDown(element, duration) {
                element.style.removeProperty('display');
                let display = window.getComputedStyle(element).display;
                if (display === 'none') {
                    display = 'block';
                }
                element.style.display = display;
                let height = element.offsetHeight;
                element.style.height = 0;
                element.style.paddingTop = 0;
                element.style.paddingBottom = 0;
                element.style.marginTop = 0;
                element.style.marginBottom = 0;
                element.style.overflow = 'hidden';
                element.offsetHeight; // force repaint
                element.style.transitionProperty = 'height, margin, padding';
                element.style.transitionDuration = duration + 'ms';
                element.style.height = height + 'px';
                element.style.removeProperty('padding-top');
                element.style.removeProperty('padding-bottom');
                element.style.removeProperty('margin-top');
                element.style.removeProperty('margin-bottom');
                window.setTimeout(function () {
                    element.style.removeProperty('height');
                    element.style.removeProperty('overflow');
                    element.style.removeProperty('transition-duration');
                    element.style.removeProperty('transition-property');
                }, duration);
            }

            applyHeatmap(); 
        });
    </script>
}