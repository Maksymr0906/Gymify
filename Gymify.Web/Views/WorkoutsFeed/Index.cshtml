@using Microsoft.AspNetCore.Mvc.Localization
@using Gymify.Application.DTOs.WorkoutsFeed
@inject IViewLocalizer Localizer
@model List<WorkoutDayDto>

@{
    ViewData["Title"] = Localizer["PageTitle"];
}

<div class="dashboard-wrapper"> 
    <div class="feed-header">
        <h2 class="feed-title">@Localizer["Header_Feed"]</h2>
    </div>

    <div class="filters-bar" id="filters-container">
        <select id="filter-type" class="gym-select">
            <option value="mine">@Localizer["Filter_Mine"]</option>
            <option value="all">@Localizer["Filter_All"]</option>
        </select>

        <input type="text"
               id="author-search"
               class="gym-search-input"
               placeholder="@Localizer["Placeholder_SearchAuthor"]"
               style="display: none;" />

        <select id="sort-type" class="gym-select">
            <option value="desc">@Localizer["Sort_Newest"]</option>
            <option value="asc">@Localizer["Sort_Oldest"]</option>
        </select>
    </div>

    <div id="workout-feed-container">
        @await Html.PartialAsync("_WorkoutsList", Model)
    </div>

    <button id="load-more-btn" data-page="1" class="gym-btn gym-btn-secondary w-100" style="margin-top: 20px">
        @Localizer["Btn_LoadMore"]
    </button>

</div>

@section Scripts {
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            // === ЗМІННІ ЛОКАЛІЗАЦІЇ ДЛЯ JS ===
            const JS_RESOURCES = {
                labelWorkouts: '@Localizer["Label_Workouts"]',
                labelXP: '@Localizer["Label_XP"]',
                msgNoWorkouts: '@Localizer["Msg_NoWorkouts"]'
            };
            // ==========================================================

            const feed = document.getElementById("workout-feed-container");
            const loadMoreBtn = document.getElementById("load-more-btn");
            const filterType = document.getElementById("filter-type");
            const authorSearch = document.getElementById("author-search");
            const sortType = document.getElementById("sort-type");

            let debounceTimer;

            // === HEATMAP LOGIC (Red -> Yellow -> Green) ===
            function getXPColor(xp, min, max) {
                if (max <= min) return "hsl(120, 75%, 90%)"; // Default green-ish
                const percentage = (xp - min) / (max - min);
                // Hue: 0 (Red) -> 120 (Green)
                const hue = percentage * 120; 
                // Lightness 90% for pastel background
                return `hsl(${hue}, 85%, 92%)`;
            }

            function applyHeatmap() {
                const onlyMy = filterType.value === "mine";
                const allDayEntries = feed.querySelectorAll(".day-entry");

                // Reset styles
                allDayEntries.forEach((day) => {
                    const header = day.querySelector(".day-header");
                    if (header) {
                        header.classList.remove("heatmap-day-active");
                        header.style.backgroundColor = "";
                    }
                    day.querySelectorAll("a[data-workout-xp]").forEach((workout) => {
                        workout.classList.remove("heatmap-workout-active");
                        workout.style.backgroundColor = "";
                    });
                });

                if (!onlyMy) return;

                const daysWithXp = Array.from(allDayEntries).filter((day) => day.dataset.dayXp);
                if (daysWithXp.length === 0) return;

                let globalMinXP = Infinity;
                let globalMaxXP = -Infinity;

                daysWithXp.forEach((day) => {
                    const xp = parseInt(day.dataset.dayXp, 10);
                    if (!isNaN(xp)) {
                        globalMinXP = Math.min(globalMinXP, xp);
                        globalMaxXP = Math.max(globalMaxXP, xp);
                    }
                });

                if (globalMinXP === Infinity) return;

                daysWithXp.forEach((day) => {
                    const dayXP = parseInt(day.dataset.dayXp, 10);
                    const header = day.querySelector(".day-header");

                    if (!isNaN(dayXP) && header) {
                        header.style.backgroundColor = getXPColor(dayXP, globalMinXP, globalMaxXP);
                        header.classList.add("heatmap-day-active");
                    }

                    const workoutsInDay = day.querySelectorAll("a[data-workout-xp]");
                    if (workoutsInDay.length === 0) return;

                    let localMinXP = Infinity;
                    let localMaxXP = -Infinity;

                    workoutsInDay.forEach((workout) => {
                        const workoutXP = parseInt(workout.dataset.workoutXp, 10);
                        if (!isNaN(workoutXP)) {
                            localMinXP = Math.min(localMinXP, workoutXP);
                            localMaxXP = Math.max(localMaxXP, workoutXP);
                        }
                    });

                    if (localMinXP === Infinity) return;

                    workoutsInDay.forEach((workout) => {
                        const workoutXP = parseInt(workout.dataset.workoutXp, 10);
                        if (isNaN(workoutXP)) return;
                        const workoutColor = getXPColor(workoutXP, localMinXP, localMaxXP);
                        workout.style.backgroundColor = workoutColor;
                        workout.classList.add("heatmap-workout-active");
                    });
                });
            }

            function getFilterParams() {
                return {
                    onlyMy: filterType.value === "mine",
                    authorName: authorSearch.value.trim(),
                    byDescending: sortType.value === "desc",
                };
            }

            async function reloadFeed() {
                const { onlyMy, authorName, byDescending } = getFilterParams();
                let params = new URLSearchParams();
                params.append("page", 0);
                params.append("onlyMy", onlyMy);
                params.append("byDescending", byDescending);
                params.append("authorName", authorName);

                const url = '@Url.Action("LoadMoreWorkouts")?' + params.toString();

                try {
                    const response = await fetch(url);
                    const html = await response.text();

                    feed.innerHTML = html;
                    loadMoreBtn.dataset.page = 1;

                    if (html.trim().length === 0) {
                        // Використовуємо локалізоване повідомлення
                        feed.innerHTML = `<p style="text-align:center; color:#777; padding:20px;">${JS_RESOURCES.msgNoWorkouts}</p>`;
                        loadMoreBtn.style.display = "none";
                    } else {
                        loadMoreBtn.style.display = "block";
                    }

                    applyHeatmap();
                } catch (e) {
                    console.error(e);
                }
            }

            async function loadMoreWorkouts() {
                const nextPage = parseInt(loadMoreBtn.dataset.page);
                const { onlyMy, authorName, byDescending } = getFilterParams();

                let params = new URLSearchParams();
                params.append('page', nextPage);
                params.append('onlyMy', onlyMy);
                params.append('byDescending', byDescending);
                params.append('authorName', authorName);

                const url = '@Url.Action("LoadMoreWorkouts")?' + params.toString();

                try {
                    const response = await fetch(url);
                    const html = await response.text();

                    if (html.trim().length === 0) {
                        loadMoreBtn.style.display = 'none';
                        return;
                    }

                    let temp = document.createElement('div');
                    temp.innerHTML = html;

                    const newDayEntries = temp.querySelectorAll('.day-entry');
                    
                    // Regex використовує локалізований лейбл для пошуку в тексті (наприклад "Workouts: 5")
                    // Важливо: переконайтесь, що Label_Workouts в .resx файлі не містить спецсимволів regex
                    const countRegex = new RegExp(JS_RESOURCES.labelWorkouts + '\\s*:\\s*(\\d+)', 'i');

                    newDayEntries.forEach(newDay => {
                        const dayId = newDay.dataset.dayId;
                        if (!dayId) {
                            feed.appendChild(newDay);
                            return;
                        }

                        const existingDay = feed.querySelector(`.day-entry[data-day-id='${dayId}']`);

                        if (existingDay) {
                            const newWorkoutList = newDay.querySelector('.workout-list');
                            const existingWorkoutList = existingDay.querySelector('.workout-list');

                            if (newWorkoutList && existingWorkoutList) {
                                const existingDayXP = parseInt(existingDay.dataset.dayXp, 10) || 0;
                                const newDayXP = parseInt(newDay.dataset.dayXp, 10) || 0;
                                const totalXP = existingDayXP + newDayXP;

                                const existingHeaderSpan = existingDay.querySelector('.day-header span:nth-child(2)');
                                const existingText = existingHeaderSpan.textContent;
                                const newText = newDay.querySelector('.day-header span:nth-child(2)').textContent;

                                const existingMatch = existingText.match(countRegex);
                                const existingWorkoutCount = existingMatch ? parseInt(existingMatch[1], 10) : 0;

                                const newMatch = newText.match(countRegex);
                                const newWorkoutCountInBatch = newMatch ? parseInt(newMatch[1], 10) : 0;

                                const totalWorkoutCount = existingWorkoutCount + newWorkoutCountInBatch;

                                while (newWorkoutList.firstChild) {
                                    existingWorkoutList.appendChild(newWorkoutList.firstChild);
                                }

                                if (onlyMy) {
                                    existingDay.dataset.dayXp = totalXP;
                                }

                                if (existingHeaderSpan) {
                                    // Формуємо новий рядок використовуючи JS ресурси
                                    let newHtml = `${JS_RESOURCES.labelWorkouts}: ${totalWorkoutCount}`;
                                    if (onlyMy) {
                                        newHtml += ` | ${JS_RESOURCES.labelXP}: ${totalXP}`;
                                    }
                                    existingHeaderSpan.innerHTML = newHtml;
                                }
                            }
                            newDay.remove();
                        } else {
                            feed.appendChild(newDay);
                        }
                    });

                    loadMoreBtn.dataset.page = nextPage + 1;
                    applyHeatmap();

                    while (temp.firstChild) {
                        feed.appendChild(temp.firstChild);
                    }

                } catch (e) {
                    console.error("Error loading more workouts:", e);
                }
            }

            filterType.addEventListener("change", function () {
                if (filterType.value === "all") {
                    authorSearch.style.display = "block";
                } else {
                    authorSearch.style.display = "none";
                    authorSearch.value = "";
                }
                reloadFeed();
            });

            sortType.addEventListener("change", reloadFeed);
            authorSearch.addEventListener("input", function () {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(reloadFeed, 400);
            });
            loadMoreBtn.addEventListener("click", loadMoreWorkouts);

            // Accordion Animation
            feed.addEventListener("click", function (event) {
                const header = event.target.closest(".day-header");
                if (header) {
                    const workoutList = header.nextElementSibling;
                    if (!workoutList) return;
                    if (workoutList.style.display === "none") {
                        slideDown(workoutList, 300);
                    } else {
                        if (window.getComputedStyle(workoutList).display !== "none") {
                             slideUp(workoutList, 300);
                        } else {
                             slideDown(workoutList, 300);
                        }
                    }
                }
            });
            
            function slideUp(element, duration) {
                element.style.height = element.offsetHeight + "px";
                element.style.transitionProperty = "height, margin, padding";
                element.style.transitionDuration = duration + "ms";
                element.style.boxSizing = "border-box";
                element.offsetHeight; 
                element.style.overflow = "hidden";
                element.style.height = 0;
                element.style.paddingTop = 0;
                element.style.paddingBottom = 0;
                element.style.marginTop = 0;
                element.style.marginBottom = 0;
                window.setTimeout(function () {
                    element.style.display = "none";
                    element.style.removeProperty("height");
                    element.style.removeProperty("padding-top");
                    element.style.removeProperty("padding-bottom");
                    element.style.removeProperty("margin-top");
                    element.style.removeProperty("margin-bottom");
                    element.style.removeProperty("overflow");
                    element.style.removeProperty("transition-duration");
                    element.style.removeProperty("transition-property");
                }, duration);
            }

            function slideDown(element, duration) {
                element.style.removeProperty("display");
                let display = window.getComputedStyle(element).display;
                if (display === "none") display = "block";
                element.style.display = display;
                let height = element.offsetHeight;
                element.style.height = 0;
                element.style.paddingTop = 0;
                element.style.paddingBottom = 0;
                element.style.marginTop = 0;
                element.style.marginBottom = 0;
                element.style.overflow = "hidden";
                element.offsetHeight;
                element.style.transitionProperty = "height, margin, padding";
                element.style.transitionDuration = duration + "ms";
                element.style.height = height + "px";
                element.style.removeProperty("padding-top");
                element.style.removeProperty("padding-bottom");
                element.style.removeProperty("margin-top");
                element.style.removeProperty("margin-bottom");
                window.setTimeout(function () {
                    element.style.removeProperty("height");
                    element.style.removeProperty("overflow");
                    element.style.removeProperty("transition-duration");
                    element.style.removeProperty("transition-property");
                }, duration);
            }

            applyHeatmap();
        });
    </script>
}