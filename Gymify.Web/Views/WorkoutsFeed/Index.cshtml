@model List<Gymify.Application.DTOs.WorkoutsCalendar.WorkoutDayDto>

@{
    ViewData["Title"] = "WorkoutsFeed";
}

<h2>Workouts Feed</h2>

<div id="filters-container" style="margin-bottom:20px;">

    <div style="display:flex; gap:20px; align-items:center;">

        <!-- Filter type -->
        <select id="filter-type" style="padding:6px 10px;">
            <option value="mine">Show my workouts</option>
            <option value="all">Show all workouts</option>
        </select>

        <!-- Search by author (hidden by default) -->
        <input type="text" id="author-search"
               placeholder="Search by author"
               style="padding:6px 10px; display:none; width:200px;" />

        <!-- Sort direction -->
        <select id="sort-type" style="padding:6px 10px;">
            <option value="desc">The newest first</option>
            <option value="asc">The oldest first</option>
        </select>
    </div>

</div>

<div id="workout-feed-container">
    @await Html.PartialAsync("WorkoutsList", Model)
</div>

<button id="load-more-btn" data-page="1" style="margin-top:20px;">
    Load more
</button>

@section Scripts {
    <script>
    document.addEventListener('DOMContentLoaded', function () {

        const feed = document.getElementById('workout-feed-container');
        const loadMoreBtn = document.getElementById('load-more-btn');

        const filterType = document.getElementById('filter-type');
        const authorSearch = document.getElementById('author-search');
        const sortType = document.getElementById('sort-type');

        let debounceTimer;

        // SHOW / HIDE AUTHOR SEARCH
        filterType.addEventListener('change', function () {
            if (filterType.value === 'all') {
                authorSearch.style.display = 'block';
            } else {
                authorSearch.style.display = 'none';
                authorSearch.value = '';
            }
            reloadFeed();
        });

        // SORT CHANGE
        sortType.addEventListener('change', function () {
            reloadFeed();
        });

        // DEBOUNCE AUTHOR SEARCH
        authorSearch.addEventListener('input', function () {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                reloadFeed();
            }, 400);
        });

        // MAIN RELOAD
            // Зроби функцію 'async'
        async function reloadFeed() {

        const onlyMy = filterType.value === 'mine';
        const authorName = authorSearch.value;
        const byDescending = sortType.value === 'desc';

        let anchorDate = null; // Змінна для якірної дати

        // НОВА ЛОГІКА:
        // Якщо сортуємо за зростанням, нам треба спершу отримати якірну дату
        if (!byDescending) {

            let anchorParams = new URLSearchParams();
            anchorParams.append('onlyMy', onlyMy);
            anchorParams.append('authorName', authorName);

            const anchorUrl = '@Url.Action("GetAnchorDate")?' + anchorParams.toString();

            try {
                // 1. Робимо запит за датою
                const response = await fetch(anchorUrl);
                const data = await response.json();
                anchorDate = data.anchorDate; // Напр.: "2025-10-04T00:00:00" або null

                if (!anchorDate) {
                    // Якщо дата null - значить, тренувань за цими фільтрами немає
                    feed.innerHTML = '<p style="text-align:center;">Workouts not found.</p>';
                    loadMoreBtn.style.display = 'none';
                    return; // Важливо: виходимо з функції
                }
            } catch (e) {
                feed.innerHTML = '<p>Error when loading.</p>';
                return;
            }
        }

        // 2. Будуємо ОСНОВНИЙ запит (як і раніше, але з дод. параметром)
        let params = new URLSearchParams();
        params.append('page', 0);
        params.append('onlyMy', onlyMy);
        params.append('byDescending', byDescending);
        params.append('authorName', authorName);

        if (anchorDate) {
            params.append('anchorDate', anchorDate);
            // Зберігаємо дату для кнопки "Load more"
            loadMoreBtn.dataset.anchorDate = anchorDate; 
        } else {
            // Очищуємо, якщо повернулись до сортування за спаданням
            loadMoreBtn.dataset.anchorDate = '';
        }

        const url = '@Url.Action("LoadMoreWorkouts")?' + params.toString();

        // 3. Завантажуємо стрічку (решта функції без змін)
        fetch(url)
            .then(r => r.text())
            .then(html => {
                feed.innerHTML = html;
                loadMoreBtn.dataset.page = 1;
                loadMoreBtn.style.display = 'block'; 

                // Перевірка, чи є що ще завантажувати (опціонально, але гарна ідея)
                if (html.trim().length === 0) {
                         feed.innerHTML = '<p style="text-align:center;">Workouts not found.</p>';
                     loadMoreBtn.style.display = 'none';
                }
            });
    }

        // LOAD MORE
        loadMoreBtn.addEventListener('click', function () {

            const nextPage = parseInt(loadMoreBtn.dataset.page);
            const onlyMy = filterType.value === 'mine';
            const authorName = authorSearch.value;
            const byDescending = sortType.value === 'desc';

            const anchorDate = loadMoreBtn.dataset.anchorDate;

            let params = new URLSearchParams();
            params.append('page', nextPage);
            params.append('onlyMy', onlyMy);
            params.append('byDescending', byDescending);
            params.append('authorName', authorName);

            if (anchorDate) { // <-- НОВА УМОВА
                params.append('anchorDate', anchorDate);
            }

            const url = '@Url.Action("LoadMoreWorkouts")?' + params.toString();

            fetch(url)
                .then(r => r.text())
                .then(html => {

                    if (html.trim().length === 0) {
                        loadMoreBtn.style.display = 'none';
                        return;
                    }

                    let temp = document.createElement('div');
                    temp.innerHTML = html;

                    while (temp.firstChild) {
                        feed.appendChild(temp.firstChild);
                    }

                    loadMoreBtn.dataset.page = nextPage + 1;
                });
        });

        // COLLAPSING
        feed.addEventListener('click', function (event) {

            if (event.target.classList.contains('day-header') ||
                event.target.closest('.day-header')) {

                var header = event.target.classList.contains('day-header')
                    ? event.target
                    : event.target.closest('.day-header');

                var workoutList = header.nextElementSibling;
                if (!workoutList) return;

                if (workoutList.style.display === 'block') {
                    slideUp(workoutList, 300);
                } else {
                    slideDown(workoutList, 300);
                }
            }
        });

        function slideUp(element, duration) {
            element.style.height = element.offsetHeight + 'px';
            element.style.transitionProperty = 'height, margin, padding';
            element.style.transitionDuration = duration + 'ms';
            element.style.boxSizing = 'border-box';
            element.offsetHeight;

            element.style.overflow = 'hidden';
            element.style.height = 0;
            element.style.paddingTop = 0;
            element.style.paddingBottom = 0;
            element.style.marginTop = 0;
            element.style.marginBottom = 0;

            window.setTimeout(function () {
                element.style.display = 'none';
                element.style.removeProperty('height');
                element.style.removeProperty('padding-top');
                element.style.removeProperty('padding-bottom');
                element.style.removeProperty('margin-top');
                element.style.removeProperty('margin-bottom');
                element.style.removeProperty('overflow');
                element.style.removeProperty('transition-duration');
                element.style.removeProperty('transition-property');
            }, duration);
        }

        function slideDown(element, duration) {
            element.style.removeProperty('display');
            let display = window.getComputedStyle(element).display;

            if (display === 'none') {
                display = 'block';
            }
            element.style.display = display;

            let height = element.offsetHeight;
            element.style.height = 0;
            element.style.paddingTop = 0;
            element.style.paddingBottom = 0;
            element.style.marginTop = 0;
            element.style.marginBottom = 0;
            element.style.overflow = 'hidden';

            element.offsetHeight;

            element.style.transitionProperty = 'height, margin, padding';
            element.style.transitionDuration = duration + 'ms';
            element.style.height = height + 'px';
            element.style.removeProperty('padding-top');
            element.style.removeProperty('padding-bottom');
            element.style.removeProperty('margin-top');
            element.style.removeProperty('margin-bottom');

            window.setTimeout(function () {
                element.style.removeProperty('height');
                element.style.removeProperty('overflow');
                element.style.removeProperty('transition-duration');
                element.style.removeProperty('transition-property');
            }, duration);
        }

    });
    </script>
}
