@using Gymify.Data.Enums
@using Gymify.Application.ViewModels.ExerciseLibrary
@model ExerciseLibraryViewModel

@{
    ViewData["Title"] = "Exercise Library";
}

<partial name="_VideoModal" />

<div class="dashboard-wrapper"> <div class="ex-header">
        <h1 class="ex-title">Exercise Library</h1>
        <p class="ex-subtitle">Discover new moves or add your own to the community.</p>
    </div>

    <div class="ex-filter-bar">
        
        <div style="flex-grow: 1; min-width: 250px;">
            <input type="text" id="filterSearch" class="gym-search-input w-100" placeholder="Search exercises..." autocomplete="off" />
        </div>

        <div style="min-width: 180px;">
            <select id="filterType" class="gym-select w-100" asp-items="Html.GetEnumSelectList<ExerciseType>()">
                <option value="">All Types</option>
            </select>
        </div>

        <div class="ex-switch-container">
            <input type="radio" id="modeVerified" name="statusMode" class="ex-switch-radio" value="false" checked>
            <label for="modeVerified" class="ex-switch-label">Verified</label>

            <input type="radio" id="modePending" name="statusMode" class="ex-switch-radio" value="true">
            <label for="modePending" class="ex-switch-label">Community</label>

            <div class="ex-switch-bg"></div>
        </div>

    </div>

    <div id="exercisesContainer" style="position: relative; min-height: 400px;">
        
        <div id="loadingSpinner">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>

        <partial name="_ExerciseGrid" model="Model" />
    </div>

</div>

@section Scripts {
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const searchInput = document.getElementById("filterSearch");
            const typeSelect = document.getElementById("filterType");
            const statusRadios = document.querySelectorAll('input[name="statusMode"]');
            const container = document.getElementById("exercisesContainer");
            const loader = document.getElementById("loadingSpinner");

            let state = {
                search: "",
                type: "",
                pendingOnly: "false",
                page: 1
            };

            // 1. AJAX Load Function
            async function loadExercises() {
                if(loader) loader.style.display = "flex";
                
                const query = new URLSearchParams({
                    search: state.search,
                    type: state.type,
                    pendingOnly: state.pendingOnly,
                    page: state.page
                });

                try {
                    const res = await fetch(`/Main/FilterExercises?${query}`);
                    const html = await res.text();

                    // Оновлення контенту
                    // Створюємо тимчасовий елемент, щоб не затерти Loader
                    // (Хоча тут ми все одно повністю оновлюємо DOM, лоадер "зникне" якщо він всередині innerHTML)
                    // Краще рішення: Loader має бути поверх контенту, тому ми оновлюємо лише сусідні елементи або весь блок
                    
                    // Але в нас Loader всередині container.
                    // Тому ми зробимо так: збережемо Loader, очистимо решту, вставимо нове
                    
                    // Зберігаємо лоадер
                    const savedLoader = container.querySelector('#loadingSpinner');
                    
                    // Парсимо новий HTML
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;

                    // Очищаємо контейнер (крім лоадера, якщо він там є, але простіше просто очистити все і додати лоадер назад)
                    container.innerHTML = '';
                    
                    // Додаємо лоадер назад (він буде схований через finally)
                    if(savedLoader) container.appendChild(savedLoader);
                    
                    // Додаємо новий контент
                    while (tempDiv.firstChild) {
                        container.appendChild(tempDiv.firstChild);
                    }

                } catch (err) {
                    console.error("Error loading exercises:", err);
                } finally {
                    if(loader) loader.style.display = "none";
                }
            }

            // 2. Debounce Helper
            function debounce(func, wait) {
                let timeout;
                return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

            // 3. Filter Change Handler
            const onFilterChange = debounce(() => {
                state.page = 1;
                state.search = searchInput.value;
                state.type = typeSelect.value;
                state.pendingOnly = document.querySelector('input[name="statusMode"]:checked').value;
                loadExercises();
            }, 400);

            // 4. Event Listeners
            searchInput.addEventListener("input", onFilterChange);
            typeSelect.addEventListener("change", onFilterChange);
            statusRadios.forEach(r => r.addEventListener("change", onFilterChange));

            // 5. Pagination Handler (Delegation)
            container.addEventListener("click", (e) => {
                if (e.target.classList.contains("page-link")) {
                    e.preventDefault();
                    const newPage = e.target.getAttribute("data-page");
                    if (newPage) {
                        state.page = newPage;
                        loadExercises();
                        container.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }
            });
        });
    </script>
}