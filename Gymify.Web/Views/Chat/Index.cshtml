@using Gymify.Application.DTOs.Chat
@using Microsoft.AspNetCore.Mvc.Localization
@using System.Globalization
@inject IViewLocalizer Localizer
@model List<ChatDto>

@{
    ViewData["Title"] = Localizer["PageTitle"];
    var currentUserId = User.FindFirst("UserProfileId")?.Value;
    var openChatId = Context.Request.Query["openChatId"].ToString();
    var currentCulture = CultureInfo.CurrentCulture.Name;
}

<div class="ch-wrapper">
    <div class="ch-container">
        <div class="ch-sidebar">
            <div class="ch-sidebar-header">
                <input type="text" class="ch-input-search" placeholder="@Localizer["Placeholder_Search"]" />
            </div>

            <div class="ch-list" id="chatList">
                @if (Model != null && Model.Any())
                {
                    foreach (var chat in Model)
                    {
                        <div class="ch-item" 
                             id="chat-item-@chat.ChatId"
                             onclick="openChat('@chat.ChatId', '@chat.ChatName', '@chat.ChatAvatarUrl', '@chat.TargetUserId', this)">

                            <img src="@chat.ChatAvatarUrl" class="ch-avatar" alt="@Localizer["Alt_Avatar"]" loading="lazy" />

                            <div class="ch-info">
                                <div class="ch-name">@chat.ChatName</div>
                                <div class="ch-preview" id="preview-@chat.ChatId">
                                    @(string.IsNullOrEmpty(chat.LastMessageContent) ? Localizer["Msg_NoMessagesYet"] : chat.LastMessageContent)
                                </div>
                            </div>

                            @if (chat.LastMessageTime.HasValue)
                            {
                                <div class="ch-time">
                                    @chat.LastMessageTime.Value.ToString("g")
                                </div>
                            }
                        </div>
                    }
                }
                else
                {
                    <div style="padding:20px; text-align:center; color:#999;">@Localizer["Msg_NoChatsYet"]</div>
                }
            </div>
        </div>

        <div class="ch-main" id="chatMainArea">
            
            <div id="chatPlaceholder" class="ch-empty">
                <i class="fa-regular fa-comments" style="font-size:4rem; margin-bottom:20px; opacity:0.2;"></i>
                <p>@Localizer["Msg_SelectChat"]</p>
            </div>

            <div id="chatHeader" class="ch-header hidden">
                <button class="ch-btn-back" id="backBtn" onclick="closeChatMobile()">
                    <i class="fa-solid fa-arrow-left"></i>
                </button>
                <a href="#" id="headerLink" class="ch-header-link">
                    <img id="headerAvatar" src="" class="ch-avatar" style="width:40px; height:40px;" alt="@Localizer["Alt_Avatar"]">
                    <div>
                        <div id="headerName" class="ch-header-name">User</div>
                    </div>
                </a>
            </div>

            <div id="messagesArea" class="ch-messages hidden"></div>

            <div id="inputArea" class="ch-input-area hidden">
                <button id="cancelEditBtn" class="ch-btn-back hidden" onclick="cancelEditMode()" style="margin-right:10px; display:none;">
                    <i class="fa-solid fa-xmark"></i>
                </button>

                <textarea id="msgInput" class="ch-input" rows="1" placeholder="@Localizer["Placeholder_TypeMessage"]"></textarea>
                
                <button class="ch-btn-send" id="sendBtn" onclick="sendMessage()">
                    <i class="fa-solid fa-arrow-up"></i>
                </button>
            </div>
        </div>
    </div>
</div>

@section scripts {
    <script>
        // --- RESOURCES & CONFIG ---
        const JS_RESOURCES = {
            loading: '@Localizer["Msg_Loading"]',
            noMessages: '@Localizer["Msg_NoMessages"]',         // "No messages here" (Main Area)
            noMessagesYet: '@Localizer["Msg_NoMessagesYet"]',   // "No messages yet" (Sidebar)
            
            errorLoading: '@Localizer["Msg_ErrorLoading"]',
            reconnecting: '@Localizer["Msg_Reconnecting"]',
            errorSending: '@Localizer["Msg_ErrorSending"]',
            errorEditing: '@Localizer["Msg_ErrorEditing"]',
            confirmDelete: '@Localizer["Msg_ConfirmDelete"]',
            errorDeleting: '@Localizer["Msg_ErrorDeleting"]',
            
            // Validation
            msgTooLong: "@Localizer["Msg_MessageTooLong"]", 
            msgEmpty: "@Localizer["Msg_MessageEmpty"]",        
            
            currentCulture: '@currentCulture' 
        };

        const MAX_MSG_LENGTH = 1000;
        let currentChatId = null;
        const currentUserId = "@currentUserId";
        let editingMessageId = null;

        // --- ELEMENTS ---
        const chatMain = document.getElementById('chatMainArea');
        const msgInput = document.getElementById('msgInput');
        const messagesArea = document.getElementById('messagesArea');
        const searchInput = document.querySelector('.ch-input-search'); 
        const sendBtn = document.getElementById('sendBtn');
        const cancelEditBtn = document.getElementById('cancelEditBtn');

        // --- 1. AUTO-RESIZE LOGIC ---
        msgInput.addEventListener('input', function() {
            this.style.height = 'auto'; 

            this.style.height = (this.scrollHeight) + 'px'; 

            if(this.value === '') {
                this.style.height = '48px';
            }
        });

        // Handle Enter (Send) vs Shift+Enter (New Line)
        msgInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); 
                sendMessage();
            }
            if (e.key === 'Escape' && editingMessageId) cancelEditMode(); 
        });

        // --- SIGNALR SETUP ---
        const chatConnection = new signalR.HubConnectionBuilder()
            .withUrl("/chatHub")
            .withAutomaticReconnect()
            .build();

        chatConnection.on("ReceiveMessage", function (msg) {
            if (currentChatId && currentChatId.toLowerCase() === msg.chatId.toLowerCase()) {
                appendMessage(msg);
                scrollToBottom();
            }
            updateSidebarPreview(msg.chatId, msg.content, msg.createdAt, true);
        });

        chatConnection.on("MessageEdited", function (msg) {
            if (currentChatId && currentChatId.toLowerCase() === msg.chatId.toLowerCase()) {
                const contentDiv = document.getElementById(`content-${msg.id}`);
                // Use innerHTML to preserve line breaks if edited
                if (contentDiv) contentDiv.innerHTML = escapeHtml(msg.content).replace(/\n/g, '<br>');
            }
            updateSidebarPreview(msg.chatId, msg.content, null, false);
        });

        chatConnection.on("MessageDeleted", function (msgId) {
            const row = document.getElementById(`row-${msgId}`);
            if (row) {
                // Додаємо клас анімації
                row.classList.add('msg-deleted');

                // Чекаємо завершення анімації (400мс як у CSS), потім видаляємо з DOM
                setTimeout(() => {
                    // Перевіряємо, чи елемент ще існує (щоб уникнути помилок)
                    if (row && row.parentNode) {
                        row.remove();
                    }
                }, 400); // Час має співпадати з transition у CSS
            }
        });

        chatConnection.on("ChatPreviewUpdated", function (data) {
            updateSidebarPreview(data.chatId, data.content, data.createdAt, false);
        });

        async function startSignalR() {
            try {
                await chatConnection.start();
                const autoOpenId = "@openChatId";
                if (autoOpenId) {
                    const chatItem = document.getElementById(`chat-item-${autoOpenId}`);
                    if (chatItem) chatItem.click();
                }
            } catch (err) { setTimeout(startSignalR, 5000); }
        }
        startSignalR();

        // --- CORE FUNCTIONS ---

        async function openChat(chatId, name, avatarUrl, targetUserId, el) {
            cancelEditMode();
            document.querySelectorAll('.ch-item').forEach(i => i.classList.remove('active'));
            if(el) {
                el.classList.add('active');
                const preview = el.querySelector('.ch-preview');
                if(preview) preview.classList.remove("new-msg");
            }

            chatMain.classList.add('active'); 
            if(window.innerWidth <= 768) document.getElementById('backBtn').style.display = 'block';
            
            document.getElementById('chatPlaceholder').classList.add('hidden');
            document.getElementById('chatHeader').classList.remove('hidden');
            document.getElementById('inputArea').classList.remove('hidden');
            messagesArea.classList.remove('hidden');

            document.getElementById('headerName').innerText = name;
            document.getElementById('headerAvatar').src = avatarUrl;
            
            const headerLink = document.getElementById('headerLink');
            if (targetUserId && targetUserId !== "null") {
                headerLink.href = `/Profile?userId=${targetUserId}`;
                headerLink.style.pointerEvents = "auto";
            } else {
                headerLink.href = "#";
                headerLink.style.pointerEvents = "none";
            }

            messagesArea.innerHTML = `<div style="text-align:center; padding:20px; color:#ccc;">${JS_RESOURCES.loading}</div>`;

            if (chatConnection.state === "Connected") {
                try {
                    if (currentChatId) await chatConnection.invoke("LeaveChat", currentChatId);
                    currentChatId = chatId;
                    await chatConnection.invoke("JoinChat", chatId);
                } catch(e) { console.error(e); }
            } else {
                currentChatId = chatId;
            }

            try {
                const res = await fetch(`/Chat/GetHistory?chatId=${chatId}`);
                if (!res.ok) throw new Error("History fetch error");
                
                const msgs = await res.json();
                messagesArea.innerHTML = '';
                
                if(msgs.length === 0) {
                    messagesArea.innerHTML = `<div style="text-align:center; padding:40px; color:#eee;">${JS_RESOURCES.noMessages}</div>`;
                }
                else msgs.forEach(m => appendMessage(m));
                
                scrollToBottom();
                if(window.innerWidth > 768) msgInput.focus();
            } catch (e) {
                messagesArea.innerHTML = `<div style="text-align:center; color:red;">${JS_RESOURCES.errorLoading}</div>`;
            }
        }

        async function sendMessage() {
            if (editingMessageId) { await submitEdit(); return; }

            const text = msgInput.value.trim();

            // --- VALIDATION ---
            if (!text) return; 
            if (text.length > MAX_MSG_LENGTH) {
                alertify.error(JS_RESOURCES.msgTooLong);
                return;
            }

            if (!currentChatId) return;
            if (chatConnection.state !== "Connected") { alert(JS_RESOURCES.reconnecting); return; }

            try {
                // Sending DTO object { chatId, content }
                const request = { chatId: currentChatId, content: text };
                await chatConnection.invoke("SendMessage", request);

                msgInput.value = '';
                msgInput.style.height = '48px'; // Reset height
                msgInput.focus();
            } catch (e) { 
                console.error(e);
                alertify.error(JS_RESOURCES.errorSending); 
            }
        }

        // --- 3. PREVIEW & LOCALIZATION LOGIC ---
        function updateSidebarPreview(chatId, text, dateStr, isNew) {
            const preview = document.getElementById(`preview-${chatId}`);
            if (!preview) return;
            
            // If text is null (message deleted) or empty, show Localized "No messages yet"
            preview.innerText = text ? text : JS_RESOURCES.noMessagesYet;
            
            if (dateStr) {
                const chatItem = document.getElementById(`chat-item-${chatId}`);
                const dateObj = new Date(dateStr);
                const timeFormatted = dateObj.toLocaleString(JS_RESOURCES.currentCulture, { 
                    day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' 
                }).replace(',', '');
                let timeDiv = chatItem.querySelector('.ch-time');
                if (timeDiv) timeDiv.innerText = timeFormatted;
            }
            if (isNew) {
                const item = document.getElementById(`chat-item-${chatId}`);
                const list = document.getElementById('chatList');
                if (item && list) list.prepend(item);
            }
        }

        // --- 2. APPEND MESSAGE (With "No Msg" clear check) ---
        function appendMessage(msg) {
            // Check if current content contains the "No messages" or "Loading" text and clear it
            if (messagesArea.innerHTML.includes(JS_RESOURCES.noMessages) || messagesArea.innerHTML.includes(JS_RESOURCES.loading)) {
                 // Double check via text content to be safe
                 if(messagesArea.innerText.includes(JS_RESOURCES.noMessages) || messagesArea.innerText.includes(JS_RESOURCES.loading)) {
                     messagesArea.innerHTML = '';
                 }
            }

            const isMe = (msg.senderId.toLowerCase() === currentUserId.toLowerCase());
            const dateObj = new Date(msg.createdAt);
            const time = dateObj.toLocaleString(JS_RESOURCES.currentCulture, { 
                day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' 
            }).replace(',', '');

            const avatarUrl = msg.senderAvatarUrl || '/Images/DefaultAvatar.png';
            const profileUrl = `/Profile?userId=${msg.senderId}`;
            const userName = escapeHtml(msg.senderName);
            
            // IMPORTANT: Convert newlines to <br> for display
            const safeContent = escapeHtml(msg.content).replace(/\n/g, '<br>');
            const rawContentSafe = escapeHtml(msg.content).replace(/'/g, "&apos;").replace(/"/g, "&quot;");

            let actionsHtml = '';
            if (isMe) {
                actionsHtml = `
                    <div class="ch-msg-actions">
                        <button class="ch-action-btn" onclick="enableEditMode('${msg.id}', '${rawContentSafe}')"><i class="fa-solid fa-pen"></i></button>
                        <button class="ch-action-btn del" onclick="deleteMessageNode('${msg.id}')"><i class="fa-solid fa-trash"></i></button>
                    </div>`;
            }

            let html = '';
            if (isMe) {
                html = `
                    <div class="ch-msg-row me" id="row-${msg.id}">
                        ${actionsHtml}
                        <div class="ch-msg me">
                            <div id="content-${msg.id}">${safeContent}</div>
                            <div class="ch-msg-time" id="meta-${msg.id}">${time}</div>
                        </div>
                        <a href="${profileUrl}"><img src="${avatarUrl}" class="ch-msg-avatar"></a>
                    </div>`;
            } else {
                html = `
                    <div class="ch-msg-row them" id="row-${msg.id}">
                        <a href="${profileUrl}" title="${userName}"><img src="${avatarUrl}" class="ch-msg-avatar"></a>
                        <div class="ch-msg them">
                            <div id="content-${msg.id}">${safeContent}</div>
                            <div class="ch-msg-time" id="meta-${msg.id}">${time}</div>
                        </div>
                    </div>`;
            }
            messagesArea.insertAdjacentHTML('beforeend', html);
        }

        function enableEditMode(msgId, content) {
            const contentDiv = document.getElementById(`content-${msgId}`);
            // If editing, get innerText to strip <br> back to newlines
            const currentText = contentDiv ? contentDiv.innerText : content;
            
            editingMessageId = msgId;
            msgInput.value = currentText;
            
            // Trigger auto-resize logic immediately for the loaded text
            msgInput.style.height = 'auto';
            msgInput.style.height = (msgInput.scrollHeight) + 'px';
            
            msgInput.focus();
            if(cancelEditBtn) cancelEditBtn.style.display = 'block';
            if(sendBtn) sendBtn.innerHTML = '<i class="fa-solid fa-check"></i>';
        }

        function cancelEditMode() {
            editingMessageId = null;
            msgInput.value = '';
            msgInput.style.height = '48px'; // Reset
            if(cancelEditBtn) cancelEditBtn.style.display = 'none';
            if(sendBtn) sendBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
        }
        
        async function submitEdit() {
            const text = msgInput.value.trim();

            if (!text) { 
                alertify.error(JS_RESOURCES.msgEmpty);
                return; 
            }
            if (text.length > MAX_MSG_LENGTH) {
               alertify.error(JS_RESOURCES.msgTooLong);
               return;
            }

            if (!editingMessageId) { cancelEditMode(); return; }

            try { 
                // Sending DTO
                const request = { messageId: editingMessageId, content: text };
                await chatConnection.invoke("EditMessage", request); 
                cancelEditMode(); 
            } 
            catch (e) { 
                console.error(e);
                alertify.error(JS_RESOURCES.errorEditing); 
            }
        }

        // --- DELETE MESSAGE (FIXED WITH ALERTIFY) ---
        function deleteMessageNode(msgId) {
            alertify.confirm(
                'Gymify', 
                JS_RESOURCES.confirmDelete, 
                async function() { 
                    try { 
                        // SignalR call
                        await chatConnection.invoke("DeleteMessage", msgId, currentChatId); 
                        // No need for explicit success message; the MessageDeleted event handles the UI update
                    } 
                    catch(e) { 
                        console.error(e);
                        if(typeof alertify !== 'undefined') alertify.error(JS_RESOURCES.errorDeleting);
                    }
                },
                function() { }
            ).set('labels', {ok:'Yes', cancel:'No'});
        }

        function scrollToBottom() { messagesArea.scrollTop = messagesArea.scrollHeight; }
        function closeChatMobile() { document.getElementById('chatMainArea').classList.remove('active'); msgInput.blur(); }
        
        function escapeHtml(text) { 
            if (!text) return ""; 
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); 
        }
        
        searchInput.addEventListener('input', function(e) {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.ch-item').forEach(item => {
                item.style.display = item.querySelector('.ch-name').innerText.toLowerCase().includes(term) ? 'flex' : 'none';
            });
        });
    </script>
}