@using Gymify.Application.DTOs.Chat
@using Microsoft.AspNetCore.Mvc.Localization
@using System.Globalization
@inject IViewLocalizer Localizer
@model List<ChatDto>

@{
    ViewData["Title"] = Localizer["PageTitle"];
    var currentUserId = User.FindFirst("UserProfileId")?.Value;
    var openChatId = Context.Request.Query["openChatId"].ToString();
    var currentCulture = CultureInfo.CurrentCulture.Name;
}

<div class="ch-wrapper">
    <div class="ch-container">
        <div class="ch-sidebar">
            <div class="ch-sidebar-header">
                <input type="text" class="ch-input-search" placeholder="@Localizer["Placeholder_Search"]" />
            </div>

            <div class="ch-list" id="chatList">
                @if (Model != null && Model.Any())
                {
                    foreach (var chat in Model)
                    {
                        <div class="ch-item" 
                             id="chat-item-@chat.ChatId"
                             onclick="openChat('@chat.ChatId', '@chat.ChatName', '@chat.ChatAvatarUrl', '@chat.TargetUserId', this)">

                            <img src="@chat.ChatAvatarUrl" class="ch-avatar" alt="@Localizer["Alt_Avatar"]" loading="lazy" />

                            <div class="ch-info">
                                <div class="ch-name">@chat.ChatName</div>
                                <div class="ch-preview @(chat.UnreadCount > 0 ? "new-msg" : "")" id="preview-@chat.ChatId">
                                    @(string.IsNullOrEmpty(chat.LastMessageContent) ? Localizer["Msg_NoMessagesYet"] : chat.LastMessageContent)
                                </div>
                            </div>

                            <div style="display:flex; flex-direction:column; align-items:flex-end;">
                                @if (chat.LastMessageTime.HasValue)
                                {
                                    <div class="ch-time">
                                        @chat.LastMessageTime.Value.ToString("g", CultureInfo.CurrentCulture)
                                    </div>
                                }
                                
                                <div id="badge-@chat.ChatId" class="unread-badge @(chat.UnreadCount > 0 ? "" : "hidden")">
                                    @chat.UnreadCount
                                </div>
                            </div>
                        </div>
                    }
                }
                else
                {
                    <div style="padding:20px; text-align:center; color:#999;">@Localizer["Msg_NoChatsYet"]</div>
                }
            </div>
        </div>

        <div class="ch-main" id="chatMainArea">
            
            <div id="chatPlaceholder" class="ch-empty">
                <i class="fa-regular fa-comments" style="font-size:4rem; margin-bottom:20px; opacity:0.2;"></i>
                <p>@Localizer["Msg_SelectChat"]</p>
            </div>

            <div id="chatHeader" class="ch-header hidden">
                <button class="ch-btn-back" id="backBtn" onclick="closeChatMobile()">
                    <i class="fa-solid fa-arrow-left"></i>
                </button>
                <a href="#" id="headerLink" class="ch-header-link">
                    <img id="headerAvatar" src="" class="ch-avatar" style="width:40px; height:40px;" alt="@Localizer["Alt_Avatar"]">
                    <div>
                        <div id="headerName" class="ch-header-name">User</div>
                    </div>
                </a>
            </div>

            <div id="messagesArea" class="ch-messages hidden"></div>

            <div id="inputArea" class="ch-input-area hidden">
                <button id="cancelEditBtn" class="ch-btn-back hidden" onclick="cancelEditMode()" style="margin-right:10px; display:none;">
                    <i class="fa-solid fa-xmark"></i>
                </button>

                <textarea id="msgInput" class="ch-input" rows="1" placeholder="@Localizer["Placeholder_TypeMessage"]"></textarea>
                
                <button class="ch-btn-send" id="sendBtn" onclick="sendMessage()">
                    <i class="fa-solid fa-arrow-up"></i>
                </button>
            </div>
        </div>
    </div>
</div>

@section scripts {
    <script>
        // --- CONFIG & RESOURCES ---
        const JS_RESOURCES = {
            loading: '@Localizer["Msg_Loading"]',
            noMessages: '@Localizer["Msg_NoMessages"]',
            noMessagesYet: '@Localizer["Msg_NoMessagesYet"]',
            errorLoading: '@Localizer["Msg_ErrorLoading"]',
            reconnecting: '@Localizer["Msg_Reconnecting"]',
            errorSending: '@Localizer["Msg_ErrorSending"]',
            errorEditing: '@Localizer["Msg_ErrorEditing"]',
            confirmDelete: '@Localizer["Msg_ConfirmDelete"]',
            errorDeleting: '@Localizer["Msg_ErrorDeleting"]',
            msgTooLong: "@Localizer["Msg_MessageTooLong"]", 
            msgEmpty: "@Localizer["Msg_MessageEmpty"]",        
            currentCulture: '@currentCulture' 
        };

        const MAX_MSG_LENGTH = 1000;
        let currentChatId = null;
        const currentUserId = "@currentUserId";
        let editingMessageId = null;

        // Elements
        const chatMain = document.getElementById('chatMainArea');
        const msgInput = document.getElementById('msgInput');
        const messagesArea = document.getElementById('messagesArea');
        const searchInput = document.querySelector('.ch-input-search'); 
        const sendBtn = document.getElementById('sendBtn');
        const cancelEditBtn = document.getElementById('cancelEditBtn');

        // --- UI LOGIC ---
        msgInput.addEventListener('input', function() {
            this.style.height = 'auto'; 
            this.style.height = (this.scrollHeight) + 'px'; 
            if(this.value === '') this.style.height = '48px';
        });

        msgInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); 
                sendMessage();
            }
            if (e.key === 'Escape' && editingMessageId) cancelEditMode(); 
        });

        // --- SIGNALR ---
        const chatConnection = new signalR.HubConnectionBuilder()
            .withUrl("/chatHub")
            .withAutomaticReconnect()
            .build();

        chatConnection.on("ReceiveMessage", function (msg) {
            
            if (currentChatId && currentChatId.toLowerCase() === msg.chatId.toLowerCase()) {
                appendMessage(msg);
                scrollToBottom();
                
                markAsReadOnServer(msg.chatId);
            } 
            else {
                incrementUnreadBadge(msg.chatId);
            }
            
            updateSidebarPreview(msg.chatId, msg.content, msg.createdAt, true);
        });

        chatConnection.on("MessageEdited", function (msg) {
            if (currentChatId && currentChatId.toLowerCase() === msg.chatId.toLowerCase()) {
                const contentDiv = document.getElementById(`content-${msg.id}`);
                if (contentDiv) contentDiv.innerHTML = escapeHtml(msg.content).replace(/\n/g, '<br>');
            }
        });

        chatConnection.on("MessageDeleted", function (msgId) {
            const row = document.getElementById(`row-${msgId}`);
            if (row) {
                row.classList.add('msg-deleted');
                setTimeout(() => { if (row) row.remove(); }, 400);
            }
        });

        chatConnection.on("ChatPreviewUpdated", function (data) {
            updateSidebarPreview(data.chatId, data.content, data.createdAt, false);
        });

        async function startSignalR() {
            try {
                await chatConnection.start();
                const autoOpenId = "@openChatId";
                if (autoOpenId) {
                    const item = document.getElementById(`chat-item-${autoOpenId}`);
                    if (item) item.click();
                }
                else {
                    await chatConnection.invoke("EnterChatSection");
                }
            } catch (err) { setTimeout(startSignalR, 5000); }
        }
        startSignalR();

        // --- CORE FUNCTIONS ---

        async function openChat(chatId, name, avatarUrl, targetUserId, el) {
            cancelEditMode();
            
            // UI Sidebar Update
            document.querySelectorAll('.ch-item').forEach(i => i.classList.remove('active'));
            if(el) {
                el.classList.add('active');
                
                const preview = el.querySelector('.ch-preview');
                if(preview) preview.classList.remove("new-msg");

                const badge = document.getElementById(`badge-${chatId}`);
                if (badge) {
                    badge.classList.add('hidden');
                    badge.innerText = '0';
                }
            }

            // Show Chat Area
            chatMain.classList.add('active'); 
            
            document.getElementById('chatPlaceholder').classList.add('hidden');
            document.getElementById('chatHeader').classList.remove('hidden');
            document.getElementById('inputArea').classList.remove('hidden');
            messagesArea.classList.remove('hidden');

            document.getElementById('headerName').innerText = name;
            document.getElementById('headerAvatar').src = avatarUrl;
            
            const headerLink = document.getElementById('headerLink');
            if (targetUserId && targetUserId !== "null") {
                headerLink.href = `/Profile?userId=${targetUserId}`;
                headerLink.style.pointerEvents = "auto";
            } else {
                headerLink.href = "#";
                headerLink.style.pointerEvents = "none";
            }

            // Join SignalR Group
            if (chatConnection.state === "Connected") {
                try {
                    if (currentChatId) await chatConnection.invoke("LeaveChat", currentChatId);
                    currentChatId = chatId;
                    await chatConnection.invoke("JoinChat", chatId);
                } catch(e) { console.error(e); }
            } else {
                currentChatId = chatId;
            }

            // Load History
            messagesArea.innerHTML = `<div style="text-align:center; padding:20px; color:#ccc;">${JS_RESOURCES.loading}</div>`;
            try {
                const res = await fetch(`/Chat/GetHistory?chatId=${chatId}`);
                if (!res.ok) throw new Error("History fetch error");
                
                const msgs = await res.json();
                messagesArea.innerHTML = '';
                
                if(msgs.length === 0) {
                    messagesArea.innerHTML = `<div style="text-align:center; padding:40px; color:#eee;">${JS_RESOURCES.noMessages}</div>`;
                }
                else msgs.forEach(m => appendMessage(m));
                
                scrollToBottom();
                if(window.innerWidth > 768) msgInput.focus();
            } catch (e) {
                messagesArea.innerHTML = `<div style="text-align:center; color:red;">${JS_RESOURCES.errorLoading}</div>`;
            }
        }

        async function sendMessage() {
            if (editingMessageId) { await submitEdit(); return; }
            const text = msgInput.value.trim();

            if (!text) return; 
            if (text.length > MAX_MSG_LENGTH) { alertify.error(JS_RESOURCES.msgTooLong); return; }
            if (!currentChatId) return;
            if (chatConnection.state !== "Connected") { alert(JS_RESOURCES.reconnecting); return; }

            try {
                const request = { chatId: currentChatId, content: text };
                await chatConnection.invoke("SendMessage", request);
                msgInput.value = '';
                msgInput.style.height = '48px'; 
                msgInput.focus();
            } catch (e) { 
                console.error(e);
                alertify.error(JS_RESOURCES.errorSending); 
            }
        }

        // --- HELPER FUNCTIONS ---
        function incrementUnreadBadge(chatId) {
            const badge = document.getElementById(`badge-${chatId}`);
            if (badge) {
                let count = parseInt(badge.innerText) || 0;
                count++;
                badge.innerText = count;
                badge.classList.remove('hidden');
            }
        }

        async function markAsReadOnServer(chatId) {
            try {
                await fetch('/Chat/MarkAsRead', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json' // Обов'язково вказуємо тип контенту
                    },
                    body: JSON.stringify(chatId) // Перетворюємо GUID в JSON-рядок "xxxxxxxx-xxxx..."
                });
            } catch (e) {
                console.error("Failed to mark as read", e);
            }
        }

        function updateSidebarPreview(chatId, text, dateStr, isNew) {
            const preview = document.getElementById(`preview-${chatId}`);
            if (!preview) return;
            
            preview.innerText = text ? text : JS_RESOURCES.noMessagesYet;
            
            if (isNew && (!currentChatId || currentChatId.toLowerCase() !== chatId.toLowerCase())) {
                 preview.classList.add("new-msg");
            } else {
                 preview.classList.remove("new-msg");
            }
            
            if (dateStr) {
                const chatItem = document.getElementById(`chat-item-${chatId}`);
                const dateObj = new Date(dateStr);
                const timeFormatted = dateObj.toLocaleString(JS_RESOURCES.currentCulture, { 
                    year: 'numeric',   
                    month: '2-digit',  
                    day: '2-digit',   
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                let timeDiv = chatItem.querySelector('.ch-time');
                if (timeDiv) timeDiv.innerText = timeFormatted;
            }
            if (isNew) {
                const item = document.getElementById(`chat-item-${chatId}`);
                const list = document.getElementById('chatList');
                if (item && list) list.prepend(item);
            }
        }

        function appendMessage(msg) {
            if (messagesArea.innerHTML.includes(JS_RESOURCES.noMessages) || messagesArea.innerHTML.includes(JS_RESOURCES.loading)) {
                 if(messagesArea.innerText.includes(JS_RESOURCES.noMessages) || messagesArea.innerText.includes(JS_RESOURCES.loading)) {
                     messagesArea.innerHTML = '';
                 }
            }

            const isMe = (msg.senderId.toLowerCase() === currentUserId.toLowerCase());
            const dateObj = new Date(msg.createdAt);
            const time = dateObj.toLocaleString(JS_RESOURCES.currentCulture, { 
                day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' 
            }).replace(',', '');

            const avatarUrl = msg.senderAvatarUrl || 'https://localhost:7102/Images/DefaultAvatar.png';
            const profileUrl = `/Profile?userId=${msg.senderId}`;
            
            const safeContent = escapeHtml(msg.content);
            const rawContentSafe = escapeHtml(msg.content).replace(/'/g, "&apos;").replace(/"/g, "&quot;");

            let actionsHtml = '';
            if (isMe) {
                actionsHtml = `
                    <div class="ch-msg-actions">
                        <button class="ch-action-btn" onclick="enableEditMode('${msg.id}', '${rawContentSafe}')"><i class="fa-solid fa-pen"></i></button>
                        <button class="ch-action-btn del" onclick="deleteMessageNode('${msg.id}')"><i class="fa-solid fa-trash"></i></button>
                    </div>`;
            }

            let html = '';
            if (isMe) {
                html = `
                    <div class="ch-msg-row me" id="row-${msg.id}">
                        ${actionsHtml}
                        <div class="ch-msg me">
                            <div id="content-${msg.id}">${safeContent}</div>
                            <div class="ch-msg-time" id="meta-${msg.id}">${time}</div>
                        </div>
                        <a href="${profileUrl}"><img src="${avatarUrl}" class="ch-msg-avatar"></a>
                    </div>`;
            } else {
                html = `
                    <div class="ch-msg-row them" id="row-${msg.id}">
                        <a href="${profileUrl}"><img src="${avatarUrl}" class="ch-msg-avatar"></a>
                        <div class="ch-msg them">
                            <div id="content-${msg.id}">${safeContent}</div>
                            <div class="ch-msg-time" id="meta-${msg.id}">${time}</div>
                        </div>
                    </div>`;
            }
            messagesArea.insertAdjacentHTML('beforeend', html);
        }

        // --- EDIT & DELETE LOGIC ---
        function enableEditMode(msgId, content) {
            const contentDiv = document.getElementById(`content-${msgId}`);
            const currentText = contentDiv ? contentDiv.innerText : content;
            editingMessageId = msgId;
            msgInput.value = currentText;
            msgInput.style.height = 'auto';
            msgInput.style.height = (msgInput.scrollHeight) + 'px';
            msgInput.focus();
            if(cancelEditBtn) cancelEditBtn.style.display = 'block';
            if(sendBtn) sendBtn.innerHTML = '<i class="fa-solid fa-check"></i>';
        }

        function cancelEditMode() {
            editingMessageId = null;
            msgInput.value = '';
            msgInput.style.height = '48px';
            if(cancelEditBtn) cancelEditBtn.style.display = 'none';
            if(sendBtn) sendBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
        }
        
        async function submitEdit() {
            const text = msgInput.value.trim();
            if (!text) { alertify.error(JS_RESOURCES.msgEmpty); return; }
            if (text.length > MAX_MSG_LENGTH) { alertify.error(JS_RESOURCES.msgTooLong); return; }
            if (!editingMessageId) { cancelEditMode(); return; }

            try { 
                const request = { messageId: editingMessageId, content: text };
                await chatConnection.invoke("EditMessage", request); 
                cancelEditMode(); 
            } 
            catch (e) { alertify.error(JS_RESOURCES.errorEditing); }
        }

        function deleteMessageNode(msgId) {
            alertify.confirm('Gymify', JS_RESOURCES.confirmDelete, async function() { 
                try { 
                    await chatConnection.invoke("DeleteMessage", msgId, currentChatId); 
                } catch(e) { alertify.error(JS_RESOURCES.errorDeleting); }
            }, function() { }).set('labels', {ok:'Yes', cancel:'No'});
        }

        function scrollToBottom() { messagesArea.scrollTop = messagesArea.scrollHeight; }
        function closeChatMobile() { document.getElementById('chatMainArea').classList.remove('active'); msgInput.blur(); chatConnection.invoke("EnterChatSection");}
        function escapeHtml(text) { 
            if (!text) return ""; 
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); 
        }
        
        searchInput.addEventListener('input', function(e) {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.ch-item').forEach(item => {
                item.style.display = item.querySelector('.ch-name').innerText.toLowerCase().includes(term) ? 'flex' : 'none';
            });
        });
    </script>
}